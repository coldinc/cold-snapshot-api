console.log("ðŸš€ Running generateFieldMap...");

import "dotenv/config";

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const TABLES = ["Contacts", "Logs", "Cold Snapshots", "Threads"];

function toCamelCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .trim()
    .split(/\s+/)
    .map((w, i) => {
      const lower = w.toLowerCase();
      return i === 0 ? lower : lower.charAt(0).toUpperCase() + lower.slice(1);
    })
    .join("");
}

function fieldToSchema(field: any): Record<string, any> {
  const type = field.type;
  const schema: Record<string, any> = {};
  const readOnlyTypes = [
    "formula",
    "rollup",
    "lookup",
    "createdTime",
    "lastModifiedTime",
    "autoNumber",
    "count"
  ];
  switch (type) {
    case "singleSelect":
      schema.type = "string";
      if (field.options?.choices) {
        schema.enum = field.options.choices.map((c: any) => c.name);
      }
      break;
    case "multipleSelects":
      schema.type = "array";
      schema.items = { type: "string" };
      if (field.options?.choices) {
        schema.items.enum = field.options.choices.map((c: any) => c.name);
      }
      break;
    case "checkbox":
      schema.type = "boolean";
      break;
    case "number":
    case "percent":
    case "currency":
    case "rating":
    case "duration":
    case "count":
      schema.type = "number";
      break;
    case "date":
    case "dateTime":
    case "createdTime":
    case "lastModifiedTime":
      schema.type = "string";
      schema.format = "date-time";
      break;
    case "multipleAttachments":
    case "multipleRecordLinks":
    case "multipleCollaborators":
      schema.type = "array";
      break;
    default:
      schema.type = "string";
  }
  if (schema.type === "array" && !schema.items) {
    schema.items = { type: "string" };
  }
  // Add readOnly flag for calculated/system fields
  if (readOnlyTypes.includes(type)) {
    schema.readOnly = true;
  }
  return schema;
}


async function main() {
  const token = process.env.AIRTABLE_TOKEN;
  const baseId = process.env.AIRTABLE_BASE_ID;
  if (!token || !baseId) {
    throw new Error("Missing AIRTABLE_TOKEN or AIRTABLE_BASE_ID environment variables");
  }

  const query = TABLES.map((t) => `tableNames[]=${encodeURIComponent(t)}`).join("&");
  const url = `https://api.airtable.com/v0/meta/bases/${baseId}/tables?${query}`;
  const res = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
  if (!res.ok) {
    throw new Error(`Failed to fetch metadata: ${res.status} ${res.statusText}`);
  }
  const data = (await res.json()) as any;
  console.log(
    "Fetched tables:",
    data.tables?.map((t: any) => t.name)
  );

  const schemaDir = path.join(__dirname, "../schemas");
  fs.mkdirSync(schemaDir, { recursive: true });

  const allMaps: Record<string, Record<string, string>> = {};
  for (const table of data.tables || []) {
    if (!TABLES.includes(table.name)) continue;
    const mapping: Record<string, string> = {};
    const properties: Record<string, any> = {};
    for (const field of table.fields || []) {
      const key = toCamelCase(field.name);
      mapping[key] = field.name;
      properties[key] = fieldToSchema(field);
    }
    allMaps[table.name] = mapping;
    const schema = {
      $schema: "http://json-schema.org/draft-07/schema#",
      title: table.name,
      type: "object",
      properties
    };
    fs.writeFileSync(path.join(schemaDir, `${toCamelCase(table.name)}.schema.json`), JSON.stringify(schema, null, 2));
  }

  const lines: string[] = [];
  lines.push("// AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY");
  lines.push("// Generated by scripts/generateFieldMap.ts");
  lines.push("");
  lines.push("function getFieldMap(tableName: string): { [key: string]: string } {");
  lines.push("  switch (tableName) {");

  for (const [table, mapping] of Object.entries(allMaps)) {
    lines.push(`    case ${JSON.stringify(table)}:`);
    lines.push("      return {");
    for (const [key, field] of Object.entries(mapping)) {
      lines.push(`        ${key}: ${JSON.stringify(field)},`);
    }
    lines.push("      };");
  }

  lines.push("    default:");
  lines.push("      return {};");
  lines.push("  }");
  lines.push("}");
  lines.push("");
  lines.push(
    "function filterMappedFields(data: Record<string, any>, fieldMap: Record<string, string>): Record<string, any> {"
  );
  lines.push("  const src = (data as any).fields || data;");
  lines.push("  const result: Record<string, any> = {};");
  lines.push("  for (const [internal, airtable] of Object.entries(fieldMap)) {");
  lines.push("    if (src[internal] !== undefined) {");
  lines.push("      result[airtable] = src[internal];");
  lines.push("    } else if (src[airtable] !== undefined) {");
  lines.push("      result[airtable] = src[airtable];");
  lines.push("    }");
  lines.push("  }");
  lines.push("  return result;");
  lines.push("}");
  lines.push("");
  lines.push("export { getFieldMap, filterMappedFields };");

  const outputPath = path.join(__dirname, "..resolveFieldMap.ts");
  fs.writeFileSync(outputPath, lines.join("\n"));
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
